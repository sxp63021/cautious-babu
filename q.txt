C++ or C questions
====================

1. Variables
2. Data structures
   Q. Where is heap data struct used?
   A. heap data struct is well suited for algo that merge sorted data streams
   Q. Where is hash tables used?
   A. Compilers make use of hash tables to lookup identifiers.
   * single linked lists
   * double linked lists
   * queue
   * stack
   * binary search tree
   * red black tree
   * hash table
   Less well known data structs ...
   * skip lists
   * traps
   * Fibonacci heaps
   * tries
   * disjoint set data struct


C++ Course content from subrat:
================================

1•	Procedural Programming
2•	Problem of  Procedural approach with OO Solution
3•	Classes & Objects
4•	The this Pointer
5•	Access Specifier
6•	Function Overloading
7•	Constructors
8•	Operator Overloading
9•	Over loading Pre, Post Incr operator
10•	Separating declaration form definition
11•	Friend Functions
12•	References
13•	Dynamic Memory Allocation
14•	Static Members
15•	Singleton Class - DP
16•	Reuse Mechanisms
17•	Association, Aggregation, composition
18•	Inheritance
19•	Constructor Calls in inheritance
20•	Types of Inheritance
21•	Polymorphism
22•	Virtual Functions
23•	VPTR and VTABLE
24•	Virtual constructor vs Destructor
25•	Different Cases of Virtual Functions
26•	File Handling
27•	Formatting Flags and Manipulators
28•	User defined Manipulators
29•	Exception Handling
30•	Multiple Inheritance
31•	Inline Functions

1•	Data Conversion
2•	Templates
3•	Free Store
4•	Linked List using C++
5•	Standard C++ Library
6•	Name space
7•	std ::string class in depth
8•	STL
9•	Using vector class
10•	Internal working of vector
11•	Using list
12•	Internal working of list
13•	Associative Containers
14•	Map
15•	Set
16•	Internal working of map and set
17•	Prequisites for user defined class to be used in STL container
18•	iterators - all about iterators
19•	STL Algorithms
20•	Functors
21•	Smart pointer
22•	Implementing your own smart pointer
23•	Using standard smart pointers
24•	Design patterns
25•	Factory
26•	Abstract Factory
27•	Singleton
28•	Observer
29•	Strategy
30•	Chain of responsibility
31•	Class design principle(SOLID)
32•	Memory pool




1. Variables
=============
Q. How computers store things in memory?

A. Signed numbers are represented in two's complement notation.
   The highest order bit is a sign bit which makes the quantity negative
    0 means positive number
    1 means negative number
   Every negative number can be obtained from the corresponding positive value 
   by inverting all the bits and adding one.
   On a 64 bit machines, integers have a range of -2pow 63 to 2 pow 63 -1. 64th
   bit is used for sign


   Unsigned numbers are saved as straight base 2 with zero and positive numbers
   only.

   Floating point numbers 1.234*10pow23 is split into matissa (1.234) and 
   exponent part (23) for the power of ten multiplier (20 zeros)
   Floating point numbers are stored in exponent notion
   http://www.cs.scranton.edu/~cil102/data_numbers.html
   IEEE 754 standard
   Speed of floating point operations, is measured in terms of FLOPS


   Characters
   Characters are normally represented as strings of seven bits each in an
   ASCII encoding.
   


Q. How to pass function or function pointer in a function?

A. A prototype for a function which takes a function parameter looks like
   the following

   void func (void (*f)(int) );

   This states that the parameter f will be a pointer to a function which has
   a void return type and which takes a single int parameter. The following fn
   (print) is an example of a function which could be passed to func as a para
   -meter because it is the proper type.

   void print (int x) {
     cout << x << endl;
   }

   FUNCTION CALL
   ______________
   When calling a function with a function parameter, the value passed must be a
   pointer to a function. Use the function's name for this:

   func(print);

   would call func, passing the print function to it.

   FUNCTION BODY
   _____________

   As with any parameter, func can now use the parameter's name in the function
   body to access the valye of the parameter. Let's say that func will apply
   the fn it is passed to the numbers 0-4. Consider first, what the loop would
   look like to call print directly:

    for (int ctr=0; ctr < 5; ctr++ ) {
      printf(ctr);
    }

   Since func's parameter declaration says that f is the name for a pointer to 
   the desired function, we recall first that if f is a pointer, then *f is the 
   thing that f points to (i.e the fn print in tis case). As a result, just 
   replace every occurence of print in the loop above with *f:

   void func (void (*f)(int) ) {
     for (int ctr = 0 ctr < 5; ctr++ ) {
       (*f)(ctr);
     }
   }

Q. In a program what are 

	#ifndef SALESP_H
	#define SALESP_H

	...

	#endif

  These are pre processor directives, to make sure code is not included
  multiple times when compiling

Q. What is object oriented design
A. Object Oriented design is the process of planning classes or objects
   with proper data encapsulation and interaction between them to solve a
   software problem.

Q. What is an object?
A. Object contains encapsulated data and procedures grouped together to 
   represent an entity.

   Object interface defines how the object can be interacted with. 

   Object Oriented programming is defined as the interaction of these objets

Q. What are the object-oriented concepts
A. The five basic concepts of object oriented design are 
   1. Object/class
   2. Encapsulation
   3. Inheritance
   4. abstraction 
   5. Polymorphism - ability to replace an object with its sub objects

Q. What is the difference between structure and class?
A. 
   * Members of a class are private by default
   * members of a structure are public by default

   Example
   _______
    For example program 1 fails in compilation and program 2 works fine.
    
    // Program 1
    #include <stdio.h>
     
    class Test {
        int x; // x is private
    };
    int main()
    {
      Test t;
      t.x = 20; // compiler error because x is private
      getchar();
      return 0;
    }
    // Program 2
    #include <stdio.h>
     
    struct Test {
        int x; // x is public
    };
    int main()
    {
      Test t;
      t.x = 20; // works fine because x is public
      getchar();
      return 0;
    }

   * When deriving a struct from a class/struct, default access specifier for
      a base class/struct is public
   * When deiving a class, default access specifier is private

   Example (Ref: http://www.geeksforgeeks.org/g-fact-76/)
   ________

   For example program 3 fails in compilation and program 4 works fine.

    // Program 3
    #include <stdio.h>
     
    class Base {
    public:
        int x;
    };
     
    class Derived : Base { }; // is equilalent to class Derived : private Base {}
     
    int main()
    {
      Derived d;
      d.x = 20; // compiler error becuase inheritance is private
      getchar();
      return 0;
    }
    // Program 4
    #include <stdio.h>
     
    class Base {
    public:
        int x;
    };
     
    struct Derived : Base { }; // is equilalent to struct Derived : public Base {}
     
    int main()
    {
      Derived d;
      d.x = 20; // works fine becuase inheritance is public
      getchar();
      return 0;
    }


Q. Do objects only contain data or do they have functions also?
A. Actually objects only contain data.
   If you do a sizeof (object), you will see that it adds up to the members
   of the object.

   The compiler creates one copy of the class member functions seperate from
   all objects of the class. All objects of the class share this one copy of
   the member functions. Each object of course, neeeds its owne copy of
   member data because data can vary between the objects. The function code is
   non-modifiable and hence can be shared amongst all objects of one class.

Q. Who can modify private data members of a class?
A.  member functions of a class or friends of a class can modify private data
    members.

Q. Can inline functions be defined inside class and implemented outside class?
A. Yes, 
   class A{
    public:
      inline void func1();
   };

   inline void A::func() {
   }

Q. Different type of 

Q. Difference between static_cast and dynamic_cast
A. various types static_cast, dynamic_Cast, const_Cast, reinerpret_cast
   C-style cast (type)value
   Function-style cast type(value)

   http://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used

   reinterpret_Cast is most dangerous. its used primarily for weird
   conversions and bit manipulations.
   like turning a raw data stream into actual data, or storing data
   in the low bits of an aligned pointer.

Q. Can constructor of a class return anything?
A. class A{
    public:
    A();
   };
   A::A() {
   }

Q. How to define a friend class?
A. 
   Lets start with friend function
   
   class Count {
     friend void setX(Count &, int); // friend fn declaration
   public:
     Count() {x = 0;}
     void print() const {cout << x << endl;}
   private:
      int x; // data member
   };

   void setX(Count &c, int val) {
     c.x = val;
   }

   int main()
   {
     Count counter;
     cout << "counter.x after instantiation : ";
     counter.print();
     cout << "coutner.x after call ro setX friend fn: ";
     setX(counter, 8);
     counter.print();
     return 0;

   }

   FRIEND CLASS

   class MyClass
   {
     friend class SecondClass;

     public:
        MyClass() : Secret(0) {}
        void printMember()
        { count << "Secret is : " << Secret << endl; }

     private:
        int Secret;
    };

    class SecondClass
    {
       public:
          void change (MyClass& yourclass, int x)
          {
             yourclass.Secrert = x;
          }
    };

    void main() {
       MyClass my_class;
       SecondClass sec_class;
       my_class.printMember();
       sec_class.change(my_class, 5);
       my_class.printMember();
    }


Q. What are public, private and protected data members?
A. A protected member variable or function is very similar to a private member 
   but it provided one additional benefit that they can be accessed in child 
   classes which are called derived classes.

       #include <iostream>
      using namespace std;
       
      class Box
      {
         protected:
            double width;
      };
       
      class SmallBox:Box // SmallBox is the derived class.
      {
         public:
            void setSmallWidth( double wid );
            double getSmallWidth( void );
      };
       
      // Member functions of child class
      double SmallBox::getSmallWidth(void)
      {
          return width ;
      }
       
      void SmallBox::setSmallWidth( double wid )
      {
          width = wid;
      }
       
      // Main function for the program
      int main( )
      {
         SmallBox box;
       
         // set box width using member function
         box.setSmallWidth(5.0);
         cout << "Width of box : "<< box.getSmallWidth() << endl;
       
         return 0;
      }


Q. What is this pointer?
A. ever object has access to its own address through a pointer called
   this.
   this pointer is not reflected in the sizeof operation.

Q. Operator Overloading, can you write some sample code?

A.  Operators that can be overloaded are <<, >>, ++, +, -, ...
    ternary operators as (?:) cannot be overloaded.

    class PhoneNumber {
       friend ostream &operator<<(ostream&, const PhoneNumber &);
       friend istream &operator>>(istream&, PhoneNumber &);
    private:
       char areaCode[4]; // 3 digit area code and null
       char exchange[4];
       char line[5];
    };

    ostream &operator<<(ostream &output, const PhoneNumber &num)
    {
      output << "(" << num.areaCode << ")"
             << num.exchange << "-" << num.line;
      return output;
    }

    istream &operator>>(istream &input, PhoneNumber &num)
    {
      input.ignore();
      input >> setw(4) >> num.areaCode;
      input.ignore(2);
      input >> setw(4) >> num.exchange;
      input.ignore();
      input >> setw(5) >> num.line;
      return input;	// enables cin >> a >> b >> c;
    }

    int main () 
    {
       PhoneNumber phone;

        cout << "Enter phone number: ";
        cin >> phone;

        cout << "The phone number entered was: " << phone << endl;
        return 0;
    }

Q. Example of derived class
   Rectangle is a derived from quadrilateral. But converse is not true.


   class Point {
    friend ostream &operator<<(ostream &, const Point &);
    public:
      Point(int = 0, int = 0);
      void setPoint(int, int);
      int getX() const {return x;}
      int gety() const {return y;}
    protected:
      int x, y;
    };

    Point::Point(int a, int b) {setPoint(a,b);}

    void Point::setPoint(int a, int b) {
      x = a;
      y = b;
    }

    ostream &operator<<(ostream &output, const Point &p)
    {
       output << "[" << p.x << ", " << p.y << "]";

       return output;
     }

    class Circle : public Point {
      friend ostream &operator<<(ostream &, const Circle &);

     public:
      // default Constructior
      Circle(double r = 0.0, int x = 0; int y = 0);

      void setRadius(double);
      double getRadius();
      double area() const; // calcu;ate area

     protected:
      double radius;
    };


   Circle::Circle(double r, int a, int b)
     : Point (a, b)  // call base-class constructor
   {
     setRadius(r);
   }

int main()
{
  Point *pointPtr = 0, p(30,50);
  Circle *circlePtr = 0, c(2.7, 120, 89);
  
  cout << "Point p: " << p << "\n Circle c: " << c << '\n';

  pointPtr = &c; // assign address of circle to pointer

Q. How to define and use semaphore?

A. 

Q. thread creation
   #inclyud <ptheread.h>

   ret = pthread_create(fn_name, attr, "Name of thread", NULL);

in the main function

  while (1) {
   FD_ZERO(fileDescriptor);
   FD_set(m_fd, &readfs);

Q. mutex attribute
   pthread_mutext_lock
   pthread_mutext_t dataMutex;

  }

Q. What does "using namespace std" do?
A. 

Q. What is the return value of main function in C/C++?
A. The return value of main should indicate how the program exited. Normally 
   exit is generally represented by a 0. Abnormal termination is usually
   signalled by a non-zero return.

   void main() is prohibited, it should be int main()

Q. What are bitwise operators
A. There are six bitwise operators
   & - the AND operator
   | - OR operator
   ^ - the XOR operator
   ~ - the ones complement or inversion operator
   >> - the right shift operator
   << - left shift operator

Q. What is the ^ XOR operator?
   ^
   The ^ (XOR) operator compares two values, and returns a value that has its 
   bits set if one or the other value has its corresponding bits set, but not 
   both. The bits are compared using the following table
   
      1   ^   1   ==   0
      1   ^   0   ==   1
      0   ^   1   ==   1
      0   ^   0   ==   0


   An ideal use for this is to toggle certain bits.


Q. What is the ~ ones complement or inversion operator

A. The ~ (Ones Complement or inversion) operator acts only on one value and it 
   inverts it, turning all the ones int zeros, and all the zeros into ones. An 
   ideal use of this would be to set certain bytes to zero, and ensuring all 
   other bytes are set to one, regardless of the size of the data. Say we want 
   to set all the bits to one except bits zero and one

BYTE b = ~0x03;
cout << "b = " << b << endl;
WORD w = ~0x03;
cout << "w = " << w << endl;

    This would result in the following calculations

    00000011  - 0x03
    11111100  - ~0x03  b

    0000000000000011  - 0x03
    1111111111111100  - ~0x03  w

    Another ideal use, is to combine it with the & operator to ensure that 
    certain bits are set to zero. Say we want to clear bit four

BYTE b = 50;
cout << "b = " << b << endl;
BYTE c = b & ~0x10;
cout << "c = " << c << endl;

    This would result in the following calculations

    00110010  - b
  & 11101111  - ~0x10
  ----------
    00100010  - result


  Reference for bit wise operators
  http://www.codeproject.com/Articles/2247/An-introduction-to-bitwise-operators#xx266839xx


Q. Name something that can be done intresting with bits?
A. Bit Fields

   Another interesting thing that can be done using bits is to have bit fields.    With bit fields you can set up minature structures within a BYTE, 
   WORD or DWORD. Say, for example, we want to keep track of dates, but we want 
   to use the least amount of memory as possible. We could declare our 
   structure this way

struct date_struct {
    BYTE day   : 5,   // 1 to 31
         month : 4,   // 1 to 12
         year  : 14;  // 0 to 9999
    } date;

    In this example, the day field takes up the lowest 5 bits, month the next 
    four, and year the next 14 bits. So we can store the date structure in 
    twenty three bits, which is contained in three BYTEs. The twenty fourth bit 
    is ignored. If I had declared it using an integer for each field, the 
    structure would have taken up 12 BYTEs.

|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|
|                               |       |       |
+------ year ---------------+ month +-- day --+

Loops - loop - for loop
========================
Q. In the for loop, what are the 3 conditions and what if 1 condition is left?
A. the three conditions in for loop are

   a. Variable initialization, 
   b. condition
   c. variable update

   IF the condition is empty, it is evaluated to be true, loop will repeat until
   something else stops it.

   If every single section is empty, we still need to put the semi colon in for
   loop, or else it is a syntax error

   If the "variable update" is left blank, it is evaluated to be true, someone
   else needs to do the variable update.


FILE FAQ
=========

q. How to get file size or number of records
A. if the record size is constant, get the header size and save it

   We can get the size of the file by doing

   struct stat st;
   if (stat(filename, &st) != 0) {
     printf("Size of file is error\n");
     return 0;
   }

   return st.st_size;

   Once you have the size, number of records is equal to
   (fileSize - headerLength)/recordSize


LINUX KERNEL Interview Quesions
================================
Reference: http://www.careercup.com/page?pid=linux-kernel-interview-questions

1. What is bottom halves and Top half? Whats their functionality?
A. When a device driver raises interrupt, the isr should be processed fast
   in the context of the isr, very little or minimal things should be done
   This is called top halves.

   Time consuming things/routines that can be processed later are referred to
   as bottom halves. Bottom halves are usually processed in a different thread
   not in the context of isr.

2. To deploy a module inside kernel, what are the possible methods?
   Mention actual difference among them?
A.  insmod and modprobe

    insmod -> accepts the paths to files. The module does not have to reside
    in /lib/modules/$(uname -r) but dependencies are not usually loaded.

    modprobe reads the modules from /lib/modules/$(uname -r)/modules.dep.bin.
    From the same file, dependencies are loaded.

3. In how many ways we can assign a major minor number to any device?
A. statically and dynamically

   statically means:

   first = mkdev(int major, int minor);
   then
   int register_chrdev_region(dev_t first, unsigned int count, char *name);

   dynamic means:

   In run time you need to create a device file, there you need to enter
   mknod /dev/filename typeofdevice majornumber minornumber

4. What is that we want to use "user virtual address" instead of "kernel virtual
   address"? List some situations when we cannot go with kernel virual address?
A. When we are running a program in userspace, we don't have access to kernel
   virtual memory addresses

   When we are running code in kernel mode, say as a kernel module or driver,
   we normally access kernel virtual memory. 

   kernel memory has a hard stack size limit, so if some computation can be
   done in an isolated memory space that needs a lot of memory, it can be done
   in userspace memory.

   crash in userspace memory can't take down the entire system 

   kernel does not map entire physical ram into its address space, so when it 
   wants to use virtual address which is not mapped inside kernel address space
   it will temporarily map those address into special region called pkmap, this
   time it needs to use virtual address.

5. How mb differes from wmb in linux, is mb equal to wmb and rmb?
A. mb = memory barrier
   make a guarantee that all memory accesses specified before the mb will happen
    before all memory accesses specified after the barries

   rmb = read memory barrier

   wmb = write memory barrier

6. kernel can access user space memory, why do we need to use copy_from_user()
   is it needed?
A. If kernel directly accesses the user data structure, system will panic
   if it is not a valid address (eq NULL pointer). To avoid this situation, 
   copy_from_user() is uses. 

7. Best synchronization techniques used in linux kernel?
A. There are two
    wait: (mutex and semaphore)
    spin: spinlock

    if the critical sectin is small, and there is no delay, then go for spinlock
    else use mutex or semaphore.

8. How function pointers are shared across different processes? using which
   IPCs?
A. There are 4 types of IPCs
   1. Pipes
   2. Shared memory
   3. Messages queues
   4. Semeaphores

   If 2 process need to share function pointers, it is better to make a library
  for that functions and use that library in your process.

9. Is linux kernel a process/thread or something else?
A. Linux kernel is a passive component of the OS. 

   Kernel is the lowest level of easily replaceable software that interfaces 
   with the hardware in your computer. It is responsible for interfacing all of
   your applications that are running in "user mode" down to the physical
   hardware and allowing process, known as server, to get information from each
   other using inter-process communication (IPC).

10. How a function from one user process can be called in another user process?
A.  use RPC

11. mention 4 IPCs used in user level process in linux?
A.  sockets, pipes, shared memory, message queues

12. write a program with 2 threads, one thread should print even and other
    should print odd, numbers should be printed in sequence, make it SMP safe?
A.  SMP = Symmetrical Multi Processing


    #include <pthread.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <semaphore.h>

    sem_t mutext1;
    sem_t mutext2;

    main()
    {
      int rc1, rc2;
      pthread_r thread1, thread2;

      sem_init(&mutext1, 0, 1);
      sem_init(&mutext2, 0, 0);
    }

13. Explain more about interrupts and interrupt handlers?
A13. Reference: https://notes.shichao.io/lkd/ch7/
     

linked list FAQ
================

1. Assume that you are given the head and tail pointers of a doubly linked list where each node can also have a single child pointer to another similar doubly linked list. There are no cycles in this structure outside of the traditional double links. Write a procedure in C++ that flattens this structure into a single list
A. 

2. Write a procedure in C that reverses the letters of a null-terminated string. Then write another procedure in C that reverses the words of a null-terminated sentence.  

A.

3. 

WiFi FAQ
==========

* 2.4 GHz or 5 GHz
* WiFi is also referred to as 802.11 standard
* range of about 20 meters or 66 feet indoors and greater outdoors
* WEP, WPA, WPA2 are encryption mechanisms
* 802.11 b and g use 2.4 GHz band
  - US allows 11 channels in 2.4 GHz band, europe, aus allow 2 more, japan 3 
  - WiFi signal makes use of 5 channels, 1 6 11 example without overlap
  - size of the band is 20 MHz

* 802.11 a uses 5 GHz band, allows 23 non-overlapping channels
  - size of the band in 


General FAQ
===========k

1. Tell me about yourself?

A1. My name is Satish Pallapotu, I have over 15 years of experience working on
    unix/linux/RTOS/VxWorks platforms software coding in C/C++ in addition to
    shell scripting, device drivers using waterfall, agile and scrum
    methodologies.

    I work on eNodeB Platform, which is a complex piece of software running
    on circuit packs housed in frames. Platform software is made use by other
    embryos like, OAM, CallP, HRAL, etc ... 
    eNB runs the wireless tower transmitting/receiving signals from
    LTE mobiles.

    I was with Lucent Technologies in the wireless division, started as a
    Junior Software Engineer, promoted to Member of Techincal Staff, and MTS1
    with added responsibility and sofrwar module ownership.
    
    I have predominantly worked in the telecom domain, extensive experience in
    TCP/IP, UPD, TCP, wireless protocols. Currently i am primarily responsible
    for timing module design/enhancements/debugging and logging.

    Lead a team, as well played a good team player. Worked with teams
    in different geographic locations. Strong communication skills, positive
    attitude, apt at bringing new ideas to the front.

    Have used coverity/valgrind/gdb tools.

1.1 Please tell me about your last project?
A.  Have worked on interrupt hub, consolidation of all interrupts into a
    single module

    Also have been working on low cost osicllator for the eNB. But this low
    cost oscillator hardware is not meeting our specs to staying locked for
    long periods of time

2. What are your strengths?
A.

3. What are your weaknesses?
A.


4. Most challenging task you have handled? And how did u accomplish it?
A. 

5. Motivation to move?
A.

6. How do you take challenges?

7. Tell me any technical problem you had to solve recently?

8. Describe a normal day in the office?

9. What process do you use to ensure accuracy?

10. Do you prefer team work or individual work?
A.  I enjoy both, working as a team increases creativity, learn new things
    allows for different view points  on approaching a task.

    Where as Working alone, will give me a chance to manage my own time, and
    test my own skills and the end result becomes my work.

    I am ok to work as the work demands.

11. Why should we hire you?
A.  You should hire me, since i do the best at everything that i do, and i 
    firmly believe that i am the right person for this position with regards
    to experience. I am sure i will be a great asset to your company since i 
    have a great personality and i strive succeeded in all aspects of my life.
    I can maximise my current experience, knowledge base and abilities to 
    benefit this company, i will not let this company down.


2. On SDCAM SoC freescale?
A. B4860 Freescale
   SoC type: Master, SoC version: rev 2.1
   eCCM2 - P4080 processor


Q. SIP Protocol?
Q. SIP FAQ?
http://en.wikipedia.org/wiki/Session_Initiation_Protocol

Q. RTOS Linux versions
   macro - 2.6.34.15
   sdcam - 3.4.43-rt56-WR5.0.1.13
   eccm2 - 2.6.34

  
UNDERSTANDING BIG AND LITTLE ENDIAN BYTE ORDER
==============================================

Ref1: http://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/
Ref2: http://www.codeproject.com/Articles/4804/Basic-concepts-on-Endianness

* Big endian machine: Stores data big-end first. When looking at multiple bytes, the first byte (lowest address) is the biggest.
* Little endian machine: Stores data little-end first. When looking at multiple bytes, the first byte is smallest.

The NUXI Problem
Issues with byte order are sometimes called the NUXI problem: UNIX stored on a big-endian machine can show up as NUXI on a little-endian one.

Suppose we want to store 4 bytes (U, N, I and X) as two shorts: UN and IX. Each letter is a entire byte, like our WXYZ example above. To store the two shorts we would write:

short *s; // pointer to set shorts
s = 0;    // point to location 0
*s = UN;  // store first short: U * 256 + N (fictional code)
s = 2;    // point to next location
*s = IX;  // store second short: I * 256 + X
This code is not specific to a machine. If we store "UN" on a machine and ask to read it back, it had better be "UN"! I don't care about endian issues, if we store a value on one machine and read it back on the same machine, it must be the same value.

However, if we look at memory one byte at a time (using our char * trick), the order could vary. On a big endian machine we see:

Byte:     U N I X
Location: 0 1 2 3
Which make sense. U is the biggest byte in "UN" and is stored first. The same goes for IX: I is the biggest, and stored first.

On a little-endian machine we would see:

Byte:     N U X I
Location: 0 1 2 3
And this makes sense also. "N" is the littlest byte in "UN" and is stored first. Again, even though the bytes are stored "backwards" in memory, the little-endian machine knows it is little endian, and interprets them correctly when reading the values back. Also, note that we can specify hex numbers such as x = 0x1234 on any machine. Even a little-endian machine knows what you mean when you write 0x1234, and won't force you to swap the values yourself (you specify the hex number to write, and it figures out the details and swaps the bytes in memory, under the covers. Tricky.).

This scenario is called the "NUXI" problem because byte sequence UNIX is interpreted as NUXI on the other type of machine. Again, this is only a problem if you exchange data -- each machine is internally consistent.


Q. How to dynamically test for the Endian type at run time?
A. As explained in Computer Animation FAQ, you can use the following function to see if your code is running on a Little- or Big-Endian system:

#define BIG_ENDIAN      0
#define LITTLE_ENDIAN   1

int TestByteOrder()
{
   short int word = 0x0001;
   char *byte = (char *) &word;
   return(byte[0] ? LITTLE_ENDIAN : BIG_ENDIAN);
}

This code assigns the value 0001h to a 16-bit integer. A char pointer is then assigned to point at the first (least-significant) byte of the integer value. If the first byte of the integer is 0x01h, then the system is Little-Endian (the 0x01h is in the lowest, or least-significant, address). If it is 0x00h then the system is Big-Endian.

Similarly,

bool IsBigEndian()
{
   short word = 0x4321;
   if((*(char *)& word) != 0x21 )
     return true;
   else 
     return false;
}

which is just the reverse of the same coin.

You can also use the standard byte order API’s to determine the byte-order of a system at run-time. For example:

bool IsBigEndian() { return( htonl(1)==1 ); }

Q. Auto detecting the correct Endian format of a data file
A. Suppose you are developing a Windows application that imports Nuclear Magnetic Resonance (NMR) spectra. High resolution NMR files are generally recorded in Silicon or Sun Workstations but recently Windows or Linux based spectrometers are emerging as practical substitutes. It turns out that you will need to know in advance the Endian format of the file to parse correctly all the information. Here are some practical guidelines you can follow to decipher the correct Endianness of a data file:

    Typically, the binary file includes a header with the information about the Endian format.
    If the header is not present , you can guess the Endian format if you know the native format of the computer from which the file comes from. For instance, if the file was created in a Sun Workstation, the Endian format will most likely be Big-Endian. 
    If none of the above points apply, the Endian format can be determined by trial and error. For example, if after reading the file assuming one format, the spectrum does not make sense, you will know that you have to use the other format. 

Date: 4th Feb'17

Q. What is ntohl, htonl routines?
A. Network byte order is big-endian, host byte order is little endian. both these functions might have the same implementation
   if you have a program, like
   int a = 0x12345678; 

    printf("Original - 0x%x\n", (a)); 
    printf("Network - 0x%x\n", htonl(a)); 
    printf("Host - 0x%x\n", ntohl(a)); 

Output:

Original - 0x12345678
Network - 0x78563412
Host - 0x78563412

http://c-faq.com/misc/endiantest.html

TCP/IP FAQ
http://www.globalguideline.com/interview_questions/Questions.php?sc=TCP_IP_Protocol

http://www.indiabix.com/networking/tcp-ip/

LTE q&A

http://www.rfwireless-world.com/jobs/LTE-interview-questions-answers.html

C/C++ FAQ
http://a4academics.com/interview-questions/57-c-plus-plus/419-cpp-interview-questions-answers?showall=&start=1


Q. What's the difference in practice between inline and #define?
A. #define is a preprocessor tool and has macro semantics. Consider this, if max(a,b) is a macro defined as

#define max(a,b) ((a)>(b)?(a):(b)):

Q. When is inline function expanded and when is macro expanded?
A. From Wiki https://en.wikipedia.org/wiki/Inline_expansion
   Inline expansion is similar to macro expansion, but occurs during compilation
   , without changing the source code (the text), while macro expansion occurs 
   prior to compilation, and results in different text that is then processed by
   the compiler.


Q. Which step of compilation by C processor will macros be expanded?
A. From Wiki https://en.wikipedia.org/wiki/C_preprocessor
   Preprocessing is defined by the first four (of eight) phases of translation 
   specified in the C Standard.

   Trigraph replacement: The preprocessor replaces trigraph sequences with the 
   characters they represent.
   Line splicing: Physical source lines that are continued with escaped newline    sequences are spliced to form logical lines.
   Tokenization: The preprocessor breaks the result into preprocessing tokens 
   and whitespace. It replaces comments with whitespace.
   Macro expansion and directive handling: Preprocessing directive lines, 
   including file inclusion and conditional compilation, are executed. The 
   preprocessor simultaneously expands macros and, in the 1999 version of the C 
   standard, handles _Pragma operators.

Q. C++ compilation/compile process?
A.
   From: http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html

Compiling a source code file in C++ is a four-step process. For example, if you have a C++ source code file named prog1.cpp and you execute the compile command

   g++ -Wall -ansi -o prog1 prog1.cpp
the compilation process looks like this:

1. The C++ preprocessor copies the contents of the included header files into the source code file, generates macro code, and replaces symbolic constants defined using #define with their values.
   preprocessing
   
2. The expanded source code file produced by the C++ preprocessor is compiled into the assembly language for the platform.
   compiling/compilation
   
3. The assembler code generated by the compiler is assembled into the object code for the platform.
   assembly
   
4. The object code file generated by the assembler is linked together with the object code files for any library functions used to produce an executable file.
   linking
   
By using appropriate compiler options, we can stop this process at any stage.

1. To stop the process after the preprocessor step, you can use the -E option:

   g++ -E prog1.cpp
The expanded source code file will be printed on standard output (the screen by default); you can redirect the output to a file if you wish. Note that the expanded source code file is often incredibly large - a 20 line source code file can easily produce an expanded file of 20,000 lines or more, depending on which header files were included.

2. To stop the process after the compile step, you can use the -S option:

   g++ -Wall -ansi -S prog1.cpp
By default, the assembler code for a source file named filename.cpp will be placed in a file named filename.s.

3. To stop the process after the assembly step, you can use the -c option:

   g++ -Wall -ansi -c prog1.cpp

By default, the assembler code for a source file named filename.cpp will be placed in a file named filename.o

Q. What are the compiler options? can you name some


09/20/2016

1. override specifier (since c++11)
   The identifier override, if used, appears immediately after the declarator in the syntax of a member function declaration or a member function definition.

  Explanation
In a member function declaration or definition, override ensures that the function is virtual and is overriding a virtual function from the base class. The program is ill-formed (a compile-time error is generated) if this is not true.
override is an identifier with a special meaning when used after member function declarators: it's not a reserved keyword otherwise.

either override or final, or final override or override final

Example
struct A
{
    virtual void foo();
    void bar();
};
 
struct B : A
{
    void foo() const override; // Error: B::foo does not override A::foo
                               // (signature mismatch)
    void foo() override; // OK: B::foo overrides A::foo
    void bar() override; // Error: A::bar is not virtual
};

http://en.cppreference.com/w/cpp/language/override



10 interview questions responses one should know

Q 1. What are you proud to have accomplished at your last job?
A 1. Let me list a few of the things i have done
     - improve logging mechanism (jotted down sunny scenario and rainy day scenarios, introduced logging in rainy day scenarios)
     - scripts for running different timing scenarios
     - automated unit testing

Q 2. How would your previous manager describe you?
A 2. trustworthy, dedicated, and creative, ready to help
     In my recent performance review, my manager commented about my readiness to help
     One team member had to leave and i readily took the testing
      activities and filled in his job role.
     When new features are being planned, i am involved for my input
     Appreaciates the logging mechanism i put in the code to better debug the problems
     Lab issues or Field issues, participate, lead the meetings with customers, giving readouts

Q 3. Why are you looking to leave your current job?
A 3. Looking to work in a different domain. Want to take on more challenges
     I am ready for another stage in my career. A new challenge. 
     I would also like to continue to grow and learn in this field and take on some
     new tasks - ones i haven't had the oppurtunity to tackle yet.

Q4.  Tell me about a time when you messed up at work. How did you fix your mistake?
A 4. Backward comaptibility was messed up.
     ?I went to the boss and explained the mistake i did
     He asked me to conduct meetings with the respective folks
     I involved the field folks, CTA, FOA personnael, directors
     explained what i did wrong and what the impacts are
     We reached out to the customer explaining the impacts and how the next software
     load will address this issue.

Q 5. What is your five year plan?
A 5. I would like to be working in a increasingly responsible position, where my talents will be utilized and work
     closely with colleagues to solve important problems. Taking on new and exciting challenges in an
     enjoyable enviroment.

      Areas of intrest personally would be big data and cloud.

Q 6. What is one of your flaws?
A 6. Loose a lot of time trying to make it perfect. I have to realign myself to strike a balance
     of effort and result. Or else the bigger things will take a beating.

Q 7. Describe how an apple tastes to someone who can't taste?
A 7. Apple is juicy, bite is cruncy, soft, mouth is filled with freshness and feel good.




http://www.gowrikumar.com/interview/index.php

Videos:
Date: 05/18/2016
C From Beginner to Expert Programming Tutorial by "Tutor 4u"
https://www.youtube.com/watch?v=YEOWWu2vkko
http://www.cquestions.com/2010/01/tricky-c-questions-and-answers.html


Q. What is the precedence of arithmetic operations?
A. Parantheses, multiplication or division, addition or subtraction

( ) 	Parentheses Evaluated first. If the parentheses are nested, the
	expression in the innermost pair is evaluated first.
	If there are several pairs of parentheses “on the
	same level” (i.e., not nested), they are evaluated
	left to right.
*, /, or % 	Multiplication Division Modulus
		Evaluated second. If there are several, they are
		evaluated left to right.
+ or - 		Addition Subtraction
		Evaluated last. If there are several, they are
		evaluated left to right.

BODMAS - Brackets, order (x**2 or sqrt of x), division, multiplicaion, addition, subtraction rule


Q. What does i++ mean in c++?
A. i++ means post increment, equivalent to i = i+1;
   it also means, use the value of i first, then increment it

How will this program work?

 int i = 1, j = 1;

 if (i++ || j++) {
  cout << "done operation" << endl;
 }

 cout << "Value of i: " << i << endl;
 cout << "Value of j: " << j << endl;


Ans: since i is 1, first it will be evaluated and incremented to 2., j will be 1

Date: 07/16/2017
=================

Karthik, asked the following question in mock interview

Q1. Difference between a struct and class?
A1. The only difference between a struct and class in C++ is the default accessibility 
    of member variables and methods. In a struct they are public; in a class they are private.

Q2. What is polymorphism?
A2. Polymorphism means having many forms. Polymorphism typically occurs when there is a hierarchy of
    classes and they are related by inheritance.
	Polymorphism means, when a member function is called, it will cause a different
	function to be executed depending on the type of object that invokes the function

Q3. What is inheritance?
A3. Inheritance in Object Oriented Programming means creating new classes from
    existing classes.
	
	New classes will inherit some of the properties (data members) and behavior of the
	existing classes (member functions)
	
	Inheritance is a technique of code reuse
	
Q4. What is Object Oriented Programming or OO concepts?
A4. OO concepts are
    1. Encapsulation
	2. Inheritance
	3. Abstraction
	4. Polymorphism
	
Q5. What is encapsulation?
A5. Encapsulation is the concept of binding together data and functions that manipulate 
    the data, that keeps both safe from outside interference and misuse.
	
Q6. What is Abstraction?
A6. Abstraction in C++ means providing only the necessary information
    to outside world and hiding other details.
	
Q7. Give an example of polymorphism? Write small code.
A7. Assume, we have Shape, point, rectanlge, circle inherit shape.

class Shape {
	public:
		virtual double area() const {return 0.0;}
		virtual double volume() const {return 0.0;}
		
		// pure virtual function overridden in derived class
		virtual void printShapeName() const = 0;
		virtual void print const = 0;
};

class Point: public Shape {
	public:
		Point (int = 0, int = 0);
		void setPoint (int, int);
		int getX() const {return X;}
		int getY() const {return Y;}
		virtual void printShapeName() const {cout << "Point: ";}
		virtual void print() const;
};
	
Point::Point (int a, int b)
{
		x = a;
		y = b;
}

void Point::print() const
{
	cout << '[' << x << "," << y << ']';
}

class Circle: public Point {
	public:
		// default constructor
		Circle (double r = 0.0, int x = 0, int y = 0);
		
		void setRadius (double);
		double getRadius() const;
		virtual double area() const;
		virtual void printShapeName() const {cout << "Circle: "; }
		virtual void print() const;
	private:
		double radius;	// radius of Circle
};

Circle::Circle(double r, int a, int b)
	: Point (a,b) // call base-class constructor
{ setRadius(r); }

void Circle::setRadius(double r) { radius = r > 0 ? r : 0; }

double Circle::getRadius() const { return radius; }

double Circle::area() const
{return 3.14149 * radius *radius; }

void Circle::print() const
{
	Point::print();
	cout << "; Radius = " << radius;
}

--------- Following details might be correct answer to question 7 -----------------------

The word polymorphism means having many forms. Typically, polymorphism occurs 
when there is a hierarchy of classes and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different 
function to be executed depending on the type of object that invokes the function.

Consider the following example where a base class has been derived by other 
two classes:

#include <iostream> 
using namespace std;
 
class Shape {
   protected:
      int width, height;
		
   public:
      Shape( int a = 0, int b = 0) {
         width = a;
         height = b;
      }
		
      int area() {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};

class Rectangle: public Shape {
   public:
      Rectangle( int a = 0, int b = 0):Shape(a, b) { }
      int area () { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};

class Triangle: public Shape{
   public:
      Triangle( int a = 0, int b = 0):Shape(a, b) { }
      int area () { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};

// Main function for the program
int main( ) {
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // store the address of Rectangle
   shape = &rec;
	
   // call rectangle area.
   shape->area();

   // store the address of Triangle
   shape = &tri;
	
   // call triangle area.
   shape->area();
   
   return 0;
}
When the above code is compiled and executed, it produces the following result:

Parent class area
Parent class area
The reason for the incorrect output is that the call of the function area() is being set 
once by the compiler as the version defined in the base class. This is called static 
resolution of the function call, or static linkage - the function call is fixed before 
the program is executed. This is also sometimes called early binding because the area() 
function is set during the compilation of the program.

But now, let's make a slight modification in our program and precede the declaration 
of area() in the Shape class with the keyword virtual so that it looks like this:

class Shape {
   protected:
      int width, height;
   public:
      Shape( int a = 0, int b = 0) {
         width = a;
         height = b;
      }
		
      virtual int area() {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
After this slight modification, when the previous example code is compiled and 
executed, it produces the following result:

Rectangle class area
Triangle class area
This time, the compiler looks at the contents of the pointer instead of it's type. 
Hence, since addresses of objects of tri and rec classes are stored in *shape the 
respective area() function is called.

As you can see, each of the child classes has a separate implementation for the function 
area(). This is how polymorphism is generally used. You have different classes with a 
function of the same name, and even the same parameters, but with different implementations.

Virtual Function
A virtual function is a function in a base class that is declared using the keyword virtual. 
Defining in a base class a virtual function, with another version in a derived class, signals 
to the compiler that we don't want static linkage for this function.

What we do want is the selection of the function to be called at any given point in the program 
to be based on the kind of object for which it is called. This sort of operation is referred to 
as dynamic linkage, or late binding.

Q8. What are different kinds of Polymorphism's?
A8. Static polymorphism and dynamic polymorphism
    Static polymorphism is done at compile time
	Dynamic polymorphism is done at run-time
	
	Above example Shape, Rectangle and Circle and function "area()"
	demonstrate dynamic and static polymorphism.
	
Q9. What does the word virtual do?
A9. There is a virtual table, entries are made into this virtual table
    Please read /** TODO **/
	
Q10. What is a pure virtual function?
A10. For a pure virtual function, it is defined as virtual f = 0; so this class cannot be
     instantiated.
	 
	 Need for pure virtual function?
	 TODO
	 
Q11. Check if a string is palindrome?

Q12. reverse a singly linked list

Q13. If you see a process is stuck and not responding? How to debug?
A13. Take a stack trace of that process?
     in solaris, u can use pstack command
	 in linux? TODO
	 
	 we can dump the core as well, but it is expensive, when doing it
	 it is not available.
	 so stack dump is less expensive than core dump

Q14. Public, protected, private table?
A14. See the table below

Base Class
member Access
Specifier			Type of Inheritance
					public inher		protected inher			private inher
					------------        ----------------        --------------
public			    public in derived	protected				private in derived
protected			protected in deri	protected				private in derived
private				hidden in deriv		hidden in derived		hidden in derived
	 
Linux/Unix
Q. Difference between process and threads?
A. Threads are used for small tasks, whereas processes are used for more "heavyweight" tasks
- basically the execution of applications. 
   Another difference between a thread and a process is that threads within the same 
   process share the same address space, whereas different processes do not.

   Threads are operating enviroment feature.

Q. Interview follow up question for the above one?
   Do you know the segments into which a program gets divided?
A. Program gets divided into Stack, Data, Code, Heap
   When you run a any C-program, its executable image is loaded into RAM of computer
   in an organized manner which is called process address space or Memory layout of
   C program
   
   This memory layout is organized in the following fashion:
   Refer: www.firmcodes.com/memory-layout-c-program-2
   
   - Text segment
   - Data segment
   - Heap segment
   - Stack segment
   - Unmapped or reserved
   
                  Higher Address      |
				  --------------------|
				   Unmapped           |    -> Commandline arg and env variables
				  --------------------|
				    Stack             |
					  | |             |    -> Stack Frames
					   V              |
					   ^              |
					  | |             |    -> Dynamic Memory
					 HEAP             |
				  --------------------| --
				   Uninitialized Data |   |
				  --------------------|   | -> Data Segment
				   Initialized Data   |   |
				  --------------------|---
				    TEXT              | -> Executable Code
				  --------------------|
                   Lower Address
				   
	Text Segment: Text segment contain executable instructions of your C program, its
	also called code segment. This is the machine language rep of the program steps to
	be carried out, including all functions making up the program, both user defined and
	system. The text segment is sharable so that only a single copy needs to be in memory
	for diff executing programs, such as text editors, shells and so on. Usually, text
	segment is read-only, to prevent a program from accidentally modifying its
	instructions.
	
   Data Segment: There are 2 sub sections here, called initialized and uninit data
	segment.
   Initialized data: It contains both static and global data that are initialized
	with non-zero values. This segment can be further classified into read-only area
	and read-write area.
	For example: The global string defined by char ss[]="hello world" and statement like
	int count = 1; outside the main would be storead in "initialized data" area with
	read-write permission. Global statement like "const int A=3" makes the variable A
	read-only and stored in "initialized data" read-only area.
   Uninitialized Data (bss segment): Uninitialized data segment is also called BSS segment
    BSS = Block Started by Symbol named after an ancient assembler operator. Uninitialized
	data segment contains all global and static variables that are initialized to zero or
	do not have explicit initialization in source code.
	
	For eg. The global variable declared as int AA would be stored in uninitialized data
	segment. A statement like static int X = 0 will also be stored in this same area
	since its value is 0. i.e in "uninitia data"
	
   Heap Segment
    The heap segment is area where dynamically allocated memory (allocated by malloc(), 
	calloc(), realloc() and new for C++) resides. When we allocate memory through dynamic 
	allocation techniques (in simple work, run time memory allocation), program acquire 
	space from system and process address space grows that's why we have an upward arrow
	for Heap.
	We can free dynamically allocated memory space (use free() or delete). Freed memory
	goes back to the heap but does not have to be returned to the system, so understand
	unordered malloc/free eventually causes heap fragmentation.
	When we use dynamic allocation for acquire memory space, we must keep track of
	allocated memory by using its address.
	Memory leak error is caused by excess use of dynamic allocation or Heap fragmentation.
	
   Stack Segment
    The stack segment is area where local variables are stored. By saying local variable
	means that all those variables which are declared in every function including main()
	in your C program.
	When we call any function, stack frame is created and when function returns, stack frame
	is destroyed including all local variables of that particular function.
	Stack frame contains some data like return address, arguments passed to it, local 
	variables, and any other information needed by the invoked function.
	A "stack pointer" (SP) keeps track of stack by each push and pop operation onto it, by
	the adjusted stack pointer to next or prev address.
	
   Unmapped or reserved segment
    Unmapped or reserved segment contain command line arguments and other program related data
	like lower address - higher address of executable image, etc ...
	
Q. Follow up question for the above question?
   Which is repeated?
A. Stack will be different for each thread. Threads of same process, do not share stack.

Another representation of the compiler, assembler, linker and loader
http://www.tenouk.com/Bufferoverflowc/Bufferoverflow1c.html
What threads share in general
https://cs.stackexchange.com/questions/48345/what-threads-share-in-general

   
Q. Similarities of thread and process?
A. i. Both have a parent process
   ii. Process has a process id same way thread has a thread id
   iii. We can create a process withing a proces same way we can create thread within a thread
   iv. Both process and thread has priorities
   v. Unlike processes, threads are not independent of one another
   vi. Unlike processes, all threads can acess every address in the task
   vii. Unlike processes, threads are designed to assist one another. Note that processes might
        or might not assist one another because they might originate from diff userspace
   viii. Thread is a light weight process, that is the only comparision, otherwise
         you cannot compare both.

   ix. A thread is contained inside a process. Multiple threads can exist within the same
       process and share resources such as memory, while diff processes do not share memory
   x. A process is an instance of a computer program, consisting of one or more threads
   xi. Each process must have at least one thread running within it, and each thread must be
       running within a process
   xii. Each process gets its own address space and memory allocation by OS, whereas thread
        makes use of its parent process resources
   xiii. When parent process dies, all of its child processes dies, but not true for threads
   
   
Q. What is init process in linux?
A. init process or /sbin/init is the ancestor of all processes. Parent id of /sbin/init is 0, 
   init is created directly by the kernel at boot time, so it does not have a parent.
   
   Linux kernel can trigger module loading events by calling "modprobe" depending on sysctl
   parameter.
   
   kthread might be the parent of all threads :)

7/24/2017

Q. Order of Operation?
A. PEDMAS (Paranthesis, Exponent, Division, Multiplication, Addition, Subtraction)

Precedence	Operator	Description								Associativity
==================================================================================
1			++ --		Suffix/postfix increment and decrement	-Left-to-right
			()			Function call
			[]			Array subscripting
			.			Structure and union member access
			->			Structure and union member access through pointer
			(type){list}	Compound literal(C99)
2			++ --		Prefix increment and decrement			-Right-to-left
			+ -			Unary plus and minus
			! ~			Logical NOT and bitwise NOT
			(type)		Type cast
			*			Indirection (dereference)
			&			Address-of
			sizeof		Size-of
			_Alignof	Alignment requirement(C11)
3			* / %		Multiplication, division, and remainder	-Left-to-right
4			+ -			Addition and subtraction
5			<< >>		Bitwise left shift and right shift
6			< <=		For relational operators < and ≤ respectively
			> >=		For relational operators > and ≥ respectively
7			== !=		For relational = and ≠ respectively
8			&			Bitwise AND
9			^			Bitwise XOR (exclusive or)
10			|			Bitwise OR (inclusive or)
11			&&			Logical AND
12			||			Logical OR
13[note 1]	?:			Ternary conditional[note 2]				-Right-to-Left
14			=			Simple assignment
			+= -=		Assignment by sum and difference
			*= /= %=	Assignment by product, quotient, and remainder
			<<= >>=		Assignment by bitwise left shift and right shift
			&= ^= |=	Assignment by bitwise AND, XOR, and OR
15			,	Comma											-Left-to-right

Q. Cut paste an ASCII table

Q. C program to change from capital to lower case

#include <stdio.h>

int lower(int a)  
{
    if ((a >= 65) && (a <= 90))
        a = a + 32; 
    return a;  
}

int _tmain(int argc, _TCHAR* argv[])
{

    putchar(lower('A')); 
    return 0;
}

Q. What is difference between single quotes and double quotes in C/C++
A. In C and in C++ single quotes identify a single character, which double
   quotes create a string literal. 'a' is a single a character literal,
   while "a" is a string literal containing an 'a' and a null terminator
   (that is a 2 char array).
Q. Can you assign char a[] = 'abc';?
A. No you cannot assign this way. we will get compiler error
   {initializer failed to determine size of 'a'}

Q. Is strcmp a C or c++?
A. strcmp is a C function. It will calculate the ASCII value of a string
   and compare that with another ASCII value. return value is 0 if both
   match or different if they don't match.
   
Q. when to use size_t?
A. Using size_t in many situations helps with portability. size_t isn't 
   always "unsigned int", but it is always the size that can represent the 
   largest possible object on the given platform. For instance, some 
   platforms have a 16-bit integer size, but use 32-bit pointers.

